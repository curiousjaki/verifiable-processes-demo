// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{
    VERIFIABLE_PROCESSING_ELF, VERIFIABLE_PROCESSING_ID
};
//use risc0_zkvm::sha::rust_crypto::Digest;
use risc0_zkvm::{compute_image_id, default_prover, ExecutorEnv, Receipt};
use log::{info, warn};
//use risc0_zkvm::sha::Digest;
use std::error::Error;
use tonic::{transport::Server, Request, Response, Status};
use proto::verifiable_processing_service_server::{VerifiableProcessingService, VerifiableProcessingServiceServer};
use proto::{ProveRequest, ProveResponse, VerifyRequest, VerifyResponse};

use std::fs::File;
use std::io::{self, Write};

pub mod proto {
    tonic::include_proto!("verifiableprocessing");
}

fn convert_to_receipt(receipt_bytes: Vec<u8>) -> Result<Receipt, Box<dyn Error>> {
    match bincode::deserialize::<Receipt>(&receipt_bytes) {
        Ok(my_data) => {
            //println!("Deserialized Data: {:?}", my_data);
            Ok(my_data)
        }
        Err(e) => {
            //eprintln!("Error deserializing: {:?}", e);
            Err(Box::new(e))
        }
    }
}

//fn print_type_of<T>(_: &T) {
//    println!("{}", std::any::type_name::<T>())
//}

//fn write_vec_to_file(filename: &str, data: Vec<u8>) -> io::Result<()> {
//    // Open the file in write-only mode, returns `io::Result<File>`
//    let mut file = File::create(filename)?;
//
//    // Write the vector to the file, returns `io::Result<()>`
//    file.write_all(&data)?;
//
//    Ok(())
//}

#[derive(Default)]
pub struct MyVerifiableProcessingService {}

#[tonic::async_trait]
impl VerifiableProcessingService for MyVerifiableProcessingService {
    async fn prove_execution(
        &self,
        request: Request<ProveRequest>,
    ) -> Result<Response<ProveResponse>, Status> {
        let req = request.into_inner();
        info!("Processing a Proving Request");

        match &req.image_id == VERIFIABLE_PROCESSING_ID {
            true => {
                let image_id: &Vec<u32> = &req.image_id;
            }
            false => {
                warn!("The image id is incorrect");
                let image_id: &Vec<u32> = VERIFIABLE_PROCESSING_ID;
            }
        }

        let env = ExecutorEnv::builder()
            .write(&req.variable_a)
            .unwrap()
            .write(&req.variable_b)
            .unwrap()
            .write(&req.operation)
            .unwrap()
            .build()
            .unwrap();

        // Obtain the default prover.
        let prover = default_prover();

        // Produce a receipt by proving the specified ELF binary.
        let receipt = prover
            .prove(env, image_id)
            .unwrap();

        // TODO: Implement code for retrieving receipt journal here.

        // For example:
        let response_value : f64 = receipt.journal.decode().unwrap();
        //write_vec_to_file("prove.txt", bincode::serialize(&receipt).unwrap()).expect("whatever");
        //print_type_of(&bincode::serialize(&receipt).unwrap());

        let reply = ProveResponse {
            response_value,
            image_id: image_id,
            receipt: bincode::serialize(&receipt).unwrap(),
        };
        //println!("{:?}",reply);
        //println!(CARBON_ACCOUNTING_ID.to_vec());
        info!("Finished a Proving Request");
        
        Ok(Response::new(reply))
    }

    async fn verify_execution(
        &self,
        request: Request<VerifyRequest>,
    ) -> Result<Response<VerifyResponse>, Status> {
        info!("Processing a verification request");
        let req = request.into_inner();
        //println!("{:?}",req);
        //let verification_value = req.verification_value;
        if req.image_id.len() != 8 {
            panic!("image_id must contain exactly 8 elements");
        }
        let image_id : [u32; 8] = req.image_id.try_into().expect("Failed to convert Vec<u32> to [u32; 8]");
        //print_type_of(&req.receipt);
        println!("the handed id is {:?} whereas the id of the hash is: {:?}",image_id,VERIFIABLE_PROCESSING_ID);
        //write_vec_to_file("verify.txt", req.receipt.clone());
        let receipt = convert_to_receipt(req.receipt).expect("Somehow the receipt convertion didnt work");
        //println!("{:?}",&receipt);
        //let is_valid_executed: bool = true; // Example logic
        // The receipt was verified at the end of proving, but the below code is an
        // example of how someone else could verify this receipt.
        let verification_result = receipt.verify(image_id);
        
        //println!("{:?}",receipt.journal.);
        let reply : VerifyResponse;
        match verification_result {
            Ok(_) => {
                reply = VerifyResponse { is_valid_executed: true };
            }
            Err(err) => {
                // Handle the error appropriately
                reply = VerifyResponse { is_valid_executed: false };
                println!("{:?}",err)
                
                // Optionally return early, panic, or perform recovery actions
            }
        }
        info!("Finished a verification request");
        Ok(Response::new(reply))
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let addr = "0.0.0.0:50051".parse().unwrap();
    let verifiable_processing_service = MyVerifiableProcessingService::default();

    info!("VerifiableProcessingServiceServer listening on {}", addr);
    info!("Proving ELF ID: {:?}", VERIFIABLE_PROCESSING_ID);

    Server::builder()
        .add_service(VerifiableProcessingServiceServer::new(verifiable_processing_service))
        .serve(addr)
        .await?;

    Ok(())
}